Кооперация потоков для высокопроизводительной обработки больших файлов.
Изучаемые системные вызовы: pthread_barrier_init(), pthread_barrier_destroy(),
pthread_barrier_wait(), mmap(), munmap().
Задание
Написать многопоточную программу sort_index для сортировки вторичного индексного
файла таблицы базы данных, работающую с файлом с использованием отображение файлов в
адресное пространство процесса. Программа должна запускаться следующим образом:
$ sort_index memsize blocks threads filenаme
Параметры командной строки:
memsize ‒ размер рабочего буфера, кратный размеру страницы (getpagesize(2))
blocks ‒ порядок (количество блоков) разбиения буфера
threads ‒ количество потоков (от k до N), где k ‒ количество процессорных ядер, N ‒ мак-
симальное количество потоков (k <= N <= 8k).
filenаme ‒ имя файла
Количество блоков должно быть степенью двойки и превышать количество потоков не ме-
нее, чем в 4 раза (при k = 4 количество блоков не должно быть менее 16). Соответственно, раз-
мер файла должен удовлетворять указанным ограничениям.
Для целей тестирования следует написать программу gen , которая будет генерировать
неотсортированный индексный файл, и программу view для отображения индексного файла на
stdout.
Алгоритм программы генерации
Генерируемый файл представляет собой вторичный индекс по времени и состоит из заго-
ловка и индексных записей фиксированной длины.
Индексная запись имеет следующую структуру:
struct index_s {
double
 time_mark; // временная метка (модифицированная юлианская дата)
uint64_t recno;
 // номер записи в таблице БД (первичный индекс)
};
Заголовок представляет собой следующую структуру
struct index_hdr_s {
uint64_t
 recsords; // количество записей
struct index_s idx[];
 // массив записей в количестве records
};
Временная метка определяется в модифицированный юлианских днях. Целая часть лежит
в пределах от 15020.0 (1900.01.01-0:0:0.0) до «вчера»8. Дробная – это часть дня (0.5 – 12:0:0.0).
Для генерации целой и дробной частей временной метки следует использовать системный гене-
ратор случайных чисел rand(3) или rand_r(3).
Первичный индекс, как вариант, может заполняться последовательно, начиная с 1, но мо-
жет быть случайным целым > 0 (в программе сортировки не используется).
8
https://en.wikipedia.org/wiki/Julian_day. Находим в таблице вариантов «Modified JD» и получаем значение
даты на сегодня. вычитаем единицу и целую часть используем как максимальное значение целой части
генерируемой даты.
13
Размер индекса в записях должен быть кратен 256 и кратно превышать планируемую вы-
деленную память для отображения. Размер индекса и имя файла указывается при запуске про-
граммы генерации.
Алгоритм программы сортировки
1) Основной поток запускает threads потоков, сообщая им адрес буфера, размер блока
memsize/blocks, и их номер от 1 до threads - 1, используя возможность передачи аргумента для
start_routine. Порожденные потоки останавливаются на барьере, ожидая прихода основного.
2) Основной поток c номером 0 открывает файл, отображает его часть размером memsize на
память и синхронизируется на барьере. Барьер «открывается» и все threads потоков входят на
равных в фазу сортировки.
3) Фаза сортировки
С каждым из блоков связана карта (массив) отсортированных блоков, в которой изначаль-
но блоки с 0 по threads-1 отмечены, как занятые.
Поток n начинает с того, что выбирает из массива блок со своим номером и его сортирует,
используя qsort(3). После того, как поток отсортировал свой первый блок, он на основе конку-
рентного захвата мьютекса, связанного с картой, получает к ней эксклюзивный доступ, отмечает
следующий свободный блок, как занятый, освобождает мьютекс и приступает к его сортировке.
Если свободных блоков нет, синхронизируется на барьере. После прохождения барьера все
блоки будут отсортированы.
4) Фаза слияния
Поскольку блоков степень двойки, слияния производятся парами в цикле.
Поток 0 сливает блоки 0 и1, поток 1 ‒ блоки 2 и 3, и так далее.
Для отметки слитых пар и не слитых используется половина карты. Если для потока нет
пары слияния, он синхронизируется на барьере.
В результате слияния количество блоков, подлежащих слиянию сокращается в два раза, а
размер их в два раза увеличивается.
После очередного прохождения барьера количество блоков, подлежащих слиянию, станет
меньше количества потоков. В этом случае распределение блоков между потоками осуще-
ствляется на основе конкурентного захвата мьютекса, связанного с картой. Потоки, котором не
досталось блока, синхронизируются на барьере.
Когда осталась последняя пара, все потоки с номером не равным нулю синхронизируются
на барьере, о поток с номером 0 выполняет слияние последней пары.
После слияния буфер становится отсортирован и подлежит сбросу в файл (munmap()).
Если не весь файл обработан, продолжаем с шага 2).
Если весь файл обработан, основной поток отправляет запрос отмены порожденным пото-
кам, выполняет слияние отсортированных частей файла и завершается.
Как вариант, потоки, которым не досталось блоков для слияния, завершаются.
